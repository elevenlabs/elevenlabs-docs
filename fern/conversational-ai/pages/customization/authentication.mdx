---
title: Authentication
subtitle: Learn how to secure access to your conversational AI agents
---

## Overview

When building conversational AI agents, you may need to restrict access to certain agents or conversations. ElevenLabs provides multiple authentication mechanisms to ensure only authorized users can interact with your agents.

## Authentication methods

ElevenLabs offers two primary methods to secure your conversational AI agents:

<CardGroup cols={2}>
  <Card title="Signed URLs" icon="signature" href="#using-signed-urls">
    Generate temporary authenticated URLs for secure client-side connections without exposing API
    keys.
  </Card>
  <Card title="Allowlists" icon="list-check" href="#using-allowlists">
    Restrict access to specific domains or hostnames that can connect to your agent.
  </Card>
</CardGroup>

## Using signed URLs

Signed URLs are the recommended approach for client-side applications. This method allows you to authenticate users without exposing your API key.

### How signed URLs work

1. Your server requests a signed URL from ElevenLabs using your API key.
2. ElevenLabs generates a temporary token and returns a signed WebSocket URL.
3. Your client application uses this signed URL to establish a WebSocket connection.
4. The signed URL expires after 15 minutes

<Warning>
  Never expose your ElevenLabs API key on the client side. Always use signed URLs for client
  applications.
</Warning>

### Requesting a signed URL

To obtain a signed URL, make a GET request to the `get_signed_url` [endpoint](/docs/conversational-ai/api-reference/conversations/get-signed-url) with your agent ID:

<CodeBlocks>
```python
import requests

API_KEY = "your-api-key"
AGENT_ID = "your-agent-id"

url = f"https://api.elevenlabs.io/v1/convai/conversation/get_signed_url?agent_id={AGENT_ID}"
headers = {
"xi-api-key": API_KEY
}

response = requests.get(url, headers=headers)
signed_url = response.json()["signed_url"]
print(signed_url)

```javascript
const API_KEY = 'your-api-key';
const AGENT_ID = 'your-agent-id';

fetch(`https://api.elevenlabs.io/v1/convai/conversation/get_signed_url?agent_id=${AGENT_ID}`, {
  headers: {
    'xi-api-key': API_KEY,
  },
})
  .then((response) => response.json())
  .then((data) => {
    const signedUrl = data.signed_url;
    console.log(signedUrl);
  });
```

```bash
curl -X GET "https://api.elevenlabs.io/v1/convai/conversation/get_signed_url?agent_id=your-agent-id" \
-H "xi-api-key: your-api-key"
```

</CodeBlocks>

### Response format

```json
{
  "signed_url": "wss://api.elevenlabs.io/v1/convai/conversation?agent_id=your-agent-id&conversation_signature=your-token"
}
```

### Request the signed URL from your client

Your client application requests the signed URL from your server.

<CodeBlocks>
```python
# Server-side code using the Python SDK
async def get_signed_url():
    try:
        client = ElevenLabs(api_key="your-api-key")
        response = await client.conversational.get_signed_url(agent_id="your-agent-id")
        return response.signed_url
    except Exception as error:
        print(f"Error getting signed URL: {error}")
        raise
```

```javascript
// Client-side code using the JavaScript SDK
async function getSignedUrl() {
  try {
    const response = await fetch('/get-conversation-url');
    if (!response.ok) {
      throw new Error('Failed to get signed URL');
    }
    const { signedUrl } = await response.json();
    return signedUrl;
  } catch (error) {
    console.error('Error getting signed URL:', error);
    throw error;
  }
}
```

</CodeBlocks>

### Connect to the websocket

Use the signed URL with our SDK to establish a connection.

<CodeBlocks>
```python
# Server-side code using the Python SDK
async def start_conversation():
    try:
        signed_url = await get_signed_url()
        conversation = Conversation(
            client=client,
            url=signed_url,
            ...
        )
        
        conversation.start_session()
        return conversation
    except Exception as error:
        print(f"Failed to start conversation: {error}")
        raise
```

```javascript
// Client-side code using the JavaScript SDK
async function startConversation() {
  try {
    const signedUrl = await getSignedUrl();
    const conversation = await Conversation.startSession({
      signedUrl,
    });

    return conversation;
  } catch (error) {
    console.error('Failed to start conversation:', error);
    throw error;
  }
}
```

</CodeBlocks>

## Token expiration

Signed URLs are valid for 15 minutes. The session can last longer, but the conversation must be initiated within the 15 minute window.

## Additional security considerations

- Implement user authentication in your application before requesting signed URLs
- Consider rate limiting to prevent abuse
- Monitor usage patterns for suspicious activity
- Implement proper error handling for authentication failures

## API Reference

For more details on the signed URL endpoint, see the [Get Signed URL API Reference](https://elevenlabs.io/docs/api-reference/conversations/get-signed-url).

## Using allowlists

Allowlists provide a way to restrict access to your conversational AI agents based on the origin domain. This ensures that only requests from approved domains can connect to your agent.

### How allowlists Work

1. You configure a list of approved hostnames for your agent
2. When a client attempts to connect, ElevenLabs checks if the request's origin matches an allowed hostname
3. If the origin is on the allowlist, the connection is permitted; otherwise, it's rejected

### Configuring allowlists

Allowlists are configured as part of your agent's authentication settings. You can specify up to 10 unique hostnames that are allowed to connect to your agent.

### Example: setting up an allowlist

<CodeBlocks>
```python
# Example of configuring an allowlist for your agent
auth_settings = AuthSettings(
    enable_auth=False,  # No signed URL required
    allowlist=[
        AllowlistItem(hostname="example.com"),
        AllowlistItem(hostname="app.example.com"),
        AllowlistItem(hostname="localhost:3000")
    ]
)

# Update your agent with these settings

agent.platform_settings.auth = auth_settings

````

</CodeBlocks>

## Combining authentication methods

For maximum security, you can combine both authentication methods:

1. Enable `enable_auth` to require signed URLs
2. Configure an allowlist to restrict which domains can request those signed URLs

This creates a two-layer authentication system where clients must:

- Connect from an approved domain
- Possess a valid signed URL

<CodeBlocks>
```python
# Example of combining both authentication methods
auth_settings = AuthSettings(
    enable_auth=True,  # Require signed URLs
    allowlist=[
        AllowlistItem(hostname="example.com"),
        AllowlistItem(hostname="app.example.com")
    ]
)
````

</CodeBlocks>

<Info>
  When both methods are enabled, requests must satisfy both requirements to be authorized. This
  provides an additional layer of security for your agents.
</Info>

## FAQ

<AccordionGroup>
  <Accordion title="Can I use the same signed URL for multiple users?">
    No, each signed URL is tied to a specific request and should not be shared between users.
    Generate a new signed URL for each user session.
  </Accordion>
  <Accordion title="What happens if the signed URL expires during a conversation?">
    If the signed URL expires (after 15 minutes), the WebSocket connection will be closed. Your
    application should handle this by requesting a new signed URL and reconnecting.
  </Accordion>
  <Accordion title="Can I restrict access to specific users?">
    The signed URL mechanism only verifies that the request came from an authorized source. To
    restrict access to specific users, implement user authentication in your application before
    requesting the signed URL.
  </Accordion>
  <Accordion title="Is there a limit to how many signed URLs I can generate?">
    There is no specific limit on the number of signed URLs you can generate, but standard API rate
    limits apply to the endpoint that generates them.
  </Accordion>
  <Accordion title="How do allowlists handle subdomains?">
    Allowlists perform exact matching on hostnames. If you want to allow both a domain and its
    subdomains, you need to add each one separately (e.g., "example.com" and "app.example.com").
  </Accordion>
  <Accordion title="Do I need to use both authentication methods?">
    No, you can use either signed URLs or allowlists independently based on your security
    requirements. For highest security, use both.
  </Accordion>
</AccordionGroup>
